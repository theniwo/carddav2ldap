#!/bin/bash

# --- Sourcing environment variables from the file generated by entrypoint ---
# This ensures all environment variables passed by Docker Compose are available.
ENV_FILE="/etc/container_environment.sh"
# Use /dev/stderr for this message so it's always visible in Docker logs if sourcing fails.
if [ -f "$ENV_FILE" ]; then
    echo "$(date): Sourcing environment variables from $ENV_FILE" >&2
    . "$ENV_FILE" # Use '.' for sourcing
else
    echo "$(date): ERROR: Environment file $ENV_FILE not found. Variables will be missing." >&2
    exit 1 # Exit if environment file is critical and missing
fi

# Activate debugging messages if DEBUG is set to "true" (case-insensitive)
if [[ "${DEBUG,,}" == "true" ]]; then
    echo "$(date): DEBUGGING MODE ACTIVE" # Added debugging mode active message
fi

# Determine if sensitive information should be censored in logs (default to true for security)
# CENSOR_SECRETS_IN_LOGS can be "true" or "false" (case-insensitive)
CENSOR_SECRETS_IN_LOGS_ENABLED=true
if [[ -n "${CENSOR_SECRETS_IN_LOGS}" && "${CENSOR_SECRETS_IN_LOGS,,}" == "false" ]]; then
    CENSOR_SECRETS_IN_LOGS_ENABLED=false
fi

# --- Logging Einstellungen ---
# Dies ist der Standard-Pfad, wenn LOG_FILE nicht gesetzt ist oder ungültig ist.
DEFAULT_FILE_LOG_PATH="/var/log/carddav2ldap/sync_output.log"
# Dies wird der tatsächliche Pfad sein, in den tee schreibt.
ACTIVE_FILE_LOG_PATH=""

# Bestimmen, ob das Logging in eine Datei aktiv sein soll und setzen Sie den Pfad.
# Logik:
# 1. Wenn LOG_FILE leer oder "false", logging deaktivieren (/dev/null).
# 2. Wenn LOG_FILE "true", Standardpfad nutzen.
# 3. Sonst (benutzerdefinierter Pfad), den Wert von LOG_FILE nutzen.
if [[ "${LOG_FILE,,}" == "false" || -z "${LOG_FILE}" ]]; then
    # File logging disabled (LOG_FILE not set or set to 'False'/'false').
    echo "$(date): File logging disabled (LOG_FILE not set or set to 'False'/'false')." | tee /dev/stdout
    ACTIVE_FILE_LOG_PATH="/dev/null"
elif [[ "${LOG_FILE,,}" == "true" ]]; then
    # LOG_FILE is explicitly set to true, use the default path.
    ACTIVE_FILE_LOG_PATH="${DEFAULT_FILE_LOG_PATH}"
    mkdir -p "$(dirname "$ACTIVE_FILE_LOG_PATH")"
    echo "$(date): File logging enabled (using default path: ${ACTIVE_FILE_LOG_PATH})." | tee -a "$ACTIVE_FILE_LOG_PATH"
else
    # LOG_FILE is set to a custom path.
    ACTIVE_FILE_LOG_PATH="${LOG_FILE}"
    mkdir -p "$(dirname "$ACTIVE_FILE_LOG_PATH")"
    echo "$(date): File logging enabled. Output also written to: ${ACTIVE_FILE_LOG_PATH}" | tee -a "$ACTIVE_FILE_LOG_PATH"
fi


# Diese Funktion leitet ihre Eingabe über `tee` weiter.
# Sie stellt sicher, dass die Ausgabe immer an stdout (für Docker-Logs) geht
# und optional an die angegebene Log-Datei.
log_and_tee() {
    # `cat` ist nötig, da tee Eingabe von stdin erwartet.
    # `tee -a` schreibt in die tatsächliche Log-Datei (oder /dev/null, wenn deaktiviert).
    # Die Ausgabe von `tee` (sein eigener stdout) wird dann vom Haupt-Cronjob-Redirect erfasst.
    cat | tee -a "$ACTIVE_FILE_LOG_PATH"
}

# Verwenden Sie nun diese Funktion, um alle Befehlsausgaben zu wrappen, die Sie loggen möchten.
echo "$(date): Starting carddav2ldap synchronization script..." | log_and_tee

# --- DEBUGGING-SCHRITT (NUR ins File-Log, NICHT Docker-Logs) ---
# Diese Ausgaben werden nur in die Log-Datei geschrieben, um die Docker-Logs sauber zu halten.
# Nur ausführen, wenn DEBUG explizit auf 'true' gesetzt ist UND Dateil-Logging aktiv ist.
if [[ "${DEBUG,,}" == "true" && "$ACTIVE_FILE_LOG_PATH" != "/dev/null" ]]; then
    echo "$(date): --- Environment variables at script start (after sourcing) ---" >> "$ACTIVE_FILE_LOG_PATH"
    # Censor sensitive environment variables if enabled
    if [[ "$CENSOR_SECRETS_IN_LOGS_ENABLED" == "true" ]]; then
        env | sed -E 's/^(LDAP_PASSWORD|CARDDAV_PASSWORD)=.*/\1=[REDACTED]/g' >> "$ACTIVE_FILE_LOG_PATH"
    else
        env >> "$ACTIVE_FILE_LOG_PATH" # Leiten Sie die Ausgabe von 'env' direkt in die Log-Datei
    fi
    echo "$(date): ----------------------------------------------------" >> "$ACTIVE_FILE_LOG_PATH"
fi
# --- ENDE DEBUGGING-SCHRITT ---

# Führen Sie das Python-Skript aus. Seine stdout/stderr wird durch log_and_tee geleitet.
# Hinweis: 2>&1 muss VOR der Pipe stehen, sonst wird nur stdout geleitet.
/usr/local/bin/python /app/sync_script.py 2>&1 | log_and_tee

echo "$(date): CardDAV to LDAP synchronization script finished." | log_and_tee

